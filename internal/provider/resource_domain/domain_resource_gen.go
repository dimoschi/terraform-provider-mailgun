// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_domain

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DomainResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"dkim_host_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set the DKIM host name for the domain that is being created.  Note, the value must be a valid domain name, and can be the domain name being created, a subdomain of the domain being created, or the root domain. This parameter cannot be used in conjunction with force_dkim_authority or  force_root_dkim_host.",
				MarkdownDescription: "Set the DKIM host name for the domain that is being created.  Note, the value must be a valid domain name, and can be the domain name being created, a subdomain of the domain being created, or the root domain. This parameter cannot be used in conjunction with force_dkim_authority or  force_root_dkim_host.",
			},
			"dkim_key_size": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The size of the new domain's DKIM key. Shall be either 1024 or 2048.",
				MarkdownDescription: "The size of the new domain's DKIM key. Shall be either 1024 or 2048.",
			},
			"dkim_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Explicitly set the value of the DKIM selector for the domain being created. If the domain key does not already exist, one will be created.  The selector must be a valid atom per RFC2822. e.g valid value `foobar`, invalid value `foo.bar`\n\nhttps://datatracker.ietf.org/doc/html/rfc2822#section-3.2.4",
				MarkdownDescription: "Explicitly set the value of the DKIM selector for the domain being created. If the domain key does not already exist, one will be created.  The selector must be a valid atom per RFC2822. e.g valid value `foobar`, invalid value `foo.bar`\n\nhttps://datatracker.ietf.org/doc/html/rfc2822#section-3.2.4",
			},
			"domain": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"created_at": schema.StringAttribute{
						Computed: true,
					},
					"disabled": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed: true,
							},
							"note": schema.StringAttribute{
								Computed: true,
							},
							"permanently": schema.BoolAttribute{
								Computed: true,
							},
							"reason": schema.StringAttribute{
								Computed: true,
							},
							"until": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: DisabledType{
							ObjectType: types.ObjectType{
								AttrTypes: DisabledValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"is_disabled": schema.BoolAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"require_tls": schema.BoolAttribute{
						Computed: true,
					},
					"skip_verification": schema.BoolAttribute{
						Computed: true,
					},
					"smtp_login": schema.StringAttribute{
						Computed: true,
					},
					"smtp_password": schema.StringAttribute{
						Computed: true,
					},
					"spam_action": schema.StringAttribute{
						Computed: true,
					},
					"state": schema.StringAttribute{
						Computed: true,
					},
					"tracking_host": schema.StringAttribute{
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
					"use_automatic_sender_security": schema.BoolAttribute{
						Computed: true,
					},
					"web_prefix": schema.StringAttribute{
						Computed: true,
					},
					"web_scheme": schema.StringAttribute{
						Computed: true,
					},
					"wildcard": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: DomainType{
					ObjectType: types.ObjectType{
						AttrTypes: DomainValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"encrypt_incoming_message": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable encrypting incoming messages for the given domain. This cannot be altered via API  after being set for security purposes. Reach out to Support to disable if necessary.  Default to false",
				MarkdownDescription: "Enable encrypting incoming messages for the given domain. This cannot be altered via API  after being set for security purposes. Reach out to Support to disable if necessary.  Default to false",
			},
			"force_dkim_authority": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If set to true, the domain will be the DKIM authority for itself even if the root domain is registered on the same mailgun account. If set to false, the domain will have the same DKIM authority as the root domain registered on the same mailgun account. Default to false.",
				MarkdownDescription: "If set to true, the domain will be the DKIM authority for itself even if the root domain is registered on the same mailgun account. If set to false, the domain will have the same DKIM authority as the root domain registered on the same mailgun account. Default to false.",
			},
			"force_root_dkim_host": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If set to true, the root domain will be the DKIM Host for the domain being created even if the root domain itself is not registered with Mailgun. The domain being created will still need to pass domain verification with valid spf records for the domain and valid DKIM record for the root domain.  This does not effect the smtp mail-from host for the domain being created. The mail-from host will remain the domain name being created, not the root domain.",
				MarkdownDescription: "If set to true, the root domain will be the DKIM Host for the domain being created even if the root domain itself is not registered with Mailgun. The domain being created will still need to pass domain verification with valid spf records for the domain and valid DKIM record for the root domain.  This does not effect the smtp mail-from host for the domain being created. The mail-from host will remain the domain name being created, not the root domain.",
			},
			"hextended": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default to false. If set to true, domain payload will include dkim_host, mailfrom_host and pod",
				MarkdownDescription: "Default to false. If set to true, domain payload will include dkim_host, mailfrom_host and pod",
			},
			"hwith_dns": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Default to true, domain payload will include sending and receiving dns records payload",
				MarkdownDescription: "Default to true, domain payload will include sending and receiving dns records payload",
			},
			"ips": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "An optional, comma-separated list of IP addresses to be assigned to this domain.If not specified, all dedicated IP addresses on the account will be assigned.If the request cannot be fulfilled (e.g. a requested IP is not assigned to the account, etc), a 400 will be returned.",
				MarkdownDescription: "An optional, comma-separated list of IP addresses to be assigned to this domain.If not specified, all dedicated IP addresses on the account will be assigned.If the request cannot be fulfilled (e.g. a requested IP is not assigned to the account, etc), a 400 will be returned.",
			},
			"message": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the new domain",
				MarkdownDescription: "The name of the new domain",
			},
			"pool_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Requested IP Pool to be assigned to the domain at creation.",
				MarkdownDescription: "Requested IP Pool to be assigned to the domain at creation.",
			},
			"receiving_dns_records": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"cached": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"is_active": schema.BoolAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"priority": schema.StringAttribute{
							Computed: true,
						},
						"record_type": schema.StringAttribute{
							Computed: true,
						},
						"valid": schema.StringAttribute{
							Computed: true,
						},
						"value": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ReceivingDnsRecordsType{
						ObjectType: types.ObjectType{
							AttrTypes: ReceivingDnsRecordsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"sending_dns_records": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"cached": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"is_active": schema.BoolAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"priority": schema.StringAttribute{
							Computed: true,
						},
						"record_type": schema.StringAttribute{
							Computed: true,
						},
						"valid": schema.StringAttribute{
							Computed: true,
						},
						"value": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: SendingDnsRecordsType{
						ObjectType: types.ObjectType{
							AttrTypes: SendingDnsRecordsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"smtp_password": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Password for SMTP authentication",
				MarkdownDescription: "Password for SMTP authentication",
			},
			"spam_action": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Disabled, block or tag. Default to disabled. If disabled, no spam filtering will occur for inbound messages.\n\nIf block, inbound spam messages will not be delivered.\n\nIf tag, inbound messages will be tagged with a spam header. See Spam Filter.",
				MarkdownDescription: "Disabled, block or tag. Default to disabled. If disabled, no spam filtering will occur for inbound messages.\n\nIf block, inbound spam messages will not be delivered.\n\nIf tag, inbound messages will be tagged with a spam header. See Spam Filter.",
			},
			"use_automatic_sender_security": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Automatic Sender Security. This requires setting DNS CNAME entries for DKIM keys instead of a TXT record. Defaults to false.",
				MarkdownDescription: "Enable Automatic Sender Security. This requires setting DNS CNAME entries for DKIM keys instead of a TXT record. Defaults to false.",
			},
			"web_prefix": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Sets your open, click and unsubscribe URLs domain name prefix. Links rewritten or added by Mailgun in your emails will look like <web_scheme>://<web_prefix>.<domain_name>/... Default to email",
				MarkdownDescription: "Sets your open, click and unsubscribe URLs domain name prefix. Links rewritten or added by Mailgun in your emails will look like <web_scheme>://<web_prefix>.<domain_name>/... Default to email",
			},
			"web_scheme": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Sets your open, click and unsubscribe URLs to use http or https. Value either `http` or `https`. Defaults to http. In order for https to work, you must have a valid cert created for your domain. See Domain Tracking for TLS cert generation.",
				MarkdownDescription: "Sets your open, click and unsubscribe URLs to use http or https. Value either `http` or `https`. Defaults to http. In order for https to work, you must have a valid cert created for your domain. See Domain Tracking for TLS cert generation.",
			},
			"wildcard": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Determines whether the domain will accept email for sub-domains when sending messages. Default to false.",
				MarkdownDescription: "Determines whether the domain will accept email for sub-domains when sending messages. Default to false.",
			},
		},
	}
}

type DomainModel struct {
	DkimHostName               types.String `tfsdk:"dkim_host_name"`
	DkimKeySize                types.String `tfsdk:"dkim_key_size"`
	DkimSelector               types.String `tfsdk:"dkim_selector"`
	Domain                     DomainValue  `tfsdk:"domain"`
	EncryptIncomingMessage     types.Bool   `tfsdk:"encrypt_incoming_message"`
	ForceDkimAuthority         types.Bool   `tfsdk:"force_dkim_authority"`
	ForceRootDkimHost          types.Bool   `tfsdk:"force_root_dkim_host"`
	Hextended                  types.Bool   `tfsdk:"hextended"`
	HwithDns                   types.Bool   `tfsdk:"hwith_dns"`
	Ips                        types.String `tfsdk:"ips"`
	Message                    types.String `tfsdk:"message"`
	Name                       types.String `tfsdk:"name"`
	PoolId                     types.String `tfsdk:"pool_id"`
	ReceivingDnsRecords        types.List   `tfsdk:"receiving_dns_records"`
	SendingDnsRecords          types.List   `tfsdk:"sending_dns_records"`
	SmtpPassword               types.String `tfsdk:"smtp_password"`
	SpamAction                 types.String `tfsdk:"spam_action"`
	UseAutomaticSenderSecurity types.Bool   `tfsdk:"use_automatic_sender_security"`
	WebPrefix                  types.String `tfsdk:"web_prefix"`
	WebScheme                  types.String `tfsdk:"web_scheme"`
	Wildcard                   types.Bool   `tfsdk:"wildcard"`
}

var _ basetypes.ObjectTypable = DomainType{}

type DomainType struct {
	basetypes.ObjectType
}

func (t DomainType) Equal(o attr.Type) bool {
	other, ok := o.(DomainType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DomainType) String() string {
	return "DomainType"
}

func (t DomainType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.ObjectValue, was: %T`, disabledAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	isDisabledAttribute, ok := attributes["is_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_disabled is missing from object`)

		return nil, diags
	}

	isDisabledVal, ok := isDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_disabled expected to be basetypes.BoolValue, was: %T`, isDisabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requireTlsAttribute, ok := attributes["require_tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_tls is missing from object`)

		return nil, diags
	}

	requireTlsVal, ok := requireTlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_tls expected to be basetypes.BoolValue, was: %T`, requireTlsAttribute))
	}

	skipVerificationAttribute, ok := attributes["skip_verification"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verification is missing from object`)

		return nil, diags
	}

	skipVerificationVal, ok := skipVerificationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verification expected to be basetypes.BoolValue, was: %T`, skipVerificationAttribute))
	}

	smtpLoginAttribute, ok := attributes["smtp_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`smtp_login is missing from object`)

		return nil, diags
	}

	smtpLoginVal, ok := smtpLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`smtp_login expected to be basetypes.StringValue, was: %T`, smtpLoginAttribute))
	}

	smtpPasswordAttribute, ok := attributes["smtp_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`smtp_password is missing from object`)

		return nil, diags
	}

	smtpPasswordVal, ok := smtpPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`smtp_password expected to be basetypes.StringValue, was: %T`, smtpPasswordAttribute))
	}

	spamActionAttribute, ok := attributes["spam_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spam_action is missing from object`)

		return nil, diags
	}

	spamActionVal, ok := spamActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spam_action expected to be basetypes.StringValue, was: %T`, spamActionAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	trackingHostAttribute, ok := attributes["tracking_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tracking_host is missing from object`)

		return nil, diags
	}

	trackingHostVal, ok := trackingHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tracking_host expected to be basetypes.StringValue, was: %T`, trackingHostAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useAutomaticSenderSecurityAttribute, ok := attributes["use_automatic_sender_security"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_automatic_sender_security is missing from object`)

		return nil, diags
	}

	useAutomaticSenderSecurityVal, ok := useAutomaticSenderSecurityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_automatic_sender_security expected to be basetypes.BoolValue, was: %T`, useAutomaticSenderSecurityAttribute))
	}

	webPrefixAttribute, ok := attributes["web_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_prefix is missing from object`)

		return nil, diags
	}

	webPrefixVal, ok := webPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_prefix expected to be basetypes.StringValue, was: %T`, webPrefixAttribute))
	}

	webSchemeAttribute, ok := attributes["web_scheme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_scheme is missing from object`)

		return nil, diags
	}

	webSchemeVal, ok := webSchemeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_scheme expected to be basetypes.StringValue, was: %T`, webSchemeAttribute))
	}

	wildcardAttribute, ok := attributes["wildcard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wildcard is missing from object`)

		return nil, diags
	}

	wildcardVal, ok := wildcardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wildcard expected to be basetypes.BoolValue, was: %T`, wildcardAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DomainValue{
		CreatedAt:                  createdAtVal,
		Disabled:                   disabledVal,
		Id:                         idVal,
		IsDisabled:                 isDisabledVal,
		Name:                       nameVal,
		RequireTls:                 requireTlsVal,
		SkipVerification:           skipVerificationVal,
		SmtpLogin:                  smtpLoginVal,
		SmtpPassword:               smtpPasswordVal,
		SpamAction:                 spamActionVal,
		State:                      stateVal,
		TrackingHost:               trackingHostVal,
		DomainType:                 typeVal,
		UseAutomaticSenderSecurity: useAutomaticSenderSecurityVal,
		WebPrefix:                  webPrefixVal,
		WebScheme:                  webSchemeVal,
		Wildcard:                   wildcardVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewDomainValueNull() DomainValue {
	return DomainValue{
		state: attr.ValueStateNull,
	}
}

func NewDomainValueUnknown() DomainValue {
	return DomainValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDomainValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DomainValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DomainValue Attribute Value",
				"While creating a DomainValue value, a missing attribute value was detected. "+
					"A DomainValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DomainValue Attribute Type",
				"While creating a DomainValue value, an invalid attribute value was detected. "+
					"A DomainValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DomainValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DomainValue Attribute Value",
				"While creating a DomainValue value, an extra attribute value was detected. "+
					"A DomainValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DomainValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDomainValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.ObjectValue, was: %T`, disabledAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	isDisabledAttribute, ok := attributes["is_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_disabled is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	isDisabledVal, ok := isDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_disabled expected to be basetypes.BoolValue, was: %T`, isDisabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requireTlsAttribute, ok := attributes["require_tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_tls is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	requireTlsVal, ok := requireTlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_tls expected to be basetypes.BoolValue, was: %T`, requireTlsAttribute))
	}

	skipVerificationAttribute, ok := attributes["skip_verification"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verification is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	skipVerificationVal, ok := skipVerificationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verification expected to be basetypes.BoolValue, was: %T`, skipVerificationAttribute))
	}

	smtpLoginAttribute, ok := attributes["smtp_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`smtp_login is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	smtpLoginVal, ok := smtpLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`smtp_login expected to be basetypes.StringValue, was: %T`, smtpLoginAttribute))
	}

	smtpPasswordAttribute, ok := attributes["smtp_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`smtp_password is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	smtpPasswordVal, ok := smtpPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`smtp_password expected to be basetypes.StringValue, was: %T`, smtpPasswordAttribute))
	}

	spamActionAttribute, ok := attributes["spam_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spam_action is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	spamActionVal, ok := spamActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spam_action expected to be basetypes.StringValue, was: %T`, spamActionAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	trackingHostAttribute, ok := attributes["tracking_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tracking_host is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	trackingHostVal, ok := trackingHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tracking_host expected to be basetypes.StringValue, was: %T`, trackingHostAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useAutomaticSenderSecurityAttribute, ok := attributes["use_automatic_sender_security"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_automatic_sender_security is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	useAutomaticSenderSecurityVal, ok := useAutomaticSenderSecurityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_automatic_sender_security expected to be basetypes.BoolValue, was: %T`, useAutomaticSenderSecurityAttribute))
	}

	webPrefixAttribute, ok := attributes["web_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_prefix is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	webPrefixVal, ok := webPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_prefix expected to be basetypes.StringValue, was: %T`, webPrefixAttribute))
	}

	webSchemeAttribute, ok := attributes["web_scheme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_scheme is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	webSchemeVal, ok := webSchemeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_scheme expected to be basetypes.StringValue, was: %T`, webSchemeAttribute))
	}

	wildcardAttribute, ok := attributes["wildcard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wildcard is missing from object`)

		return NewDomainValueUnknown(), diags
	}

	wildcardVal, ok := wildcardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wildcard expected to be basetypes.BoolValue, was: %T`, wildcardAttribute))
	}

	if diags.HasError() {
		return NewDomainValueUnknown(), diags
	}

	return DomainValue{
		CreatedAt:                  createdAtVal,
		Disabled:                   disabledVal,
		Id:                         idVal,
		IsDisabled:                 isDisabledVal,
		Name:                       nameVal,
		RequireTls:                 requireTlsVal,
		SkipVerification:           skipVerificationVal,
		SmtpLogin:                  smtpLoginVal,
		SmtpPassword:               smtpPasswordVal,
		SpamAction:                 spamActionVal,
		State:                      stateVal,
		TrackingHost:               trackingHostVal,
		DomainType:                 typeVal,
		UseAutomaticSenderSecurity: useAutomaticSenderSecurityVal,
		WebPrefix:                  webPrefixVal,
		WebScheme:                  webSchemeVal,
		Wildcard:                   wildcardVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewDomainValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DomainValue {
	object, diags := NewDomainValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDomainValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DomainType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDomainValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDomainValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDomainValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDomainValueMust(DomainValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DomainType) ValueType(ctx context.Context) attr.Value {
	return DomainValue{}
}

var _ basetypes.ObjectValuable = DomainValue{}

type DomainValue struct {
	CreatedAt                  basetypes.StringValue `tfsdk:"created_at"`
	Disabled                   basetypes.ObjectValue `tfsdk:"disabled"`
	Id                         basetypes.StringValue `tfsdk:"id"`
	IsDisabled                 basetypes.BoolValue   `tfsdk:"is_disabled"`
	Name                       basetypes.StringValue `tfsdk:"name"`
	RequireTls                 basetypes.BoolValue   `tfsdk:"require_tls"`
	SkipVerification           basetypes.BoolValue   `tfsdk:"skip_verification"`
	SmtpLogin                  basetypes.StringValue `tfsdk:"smtp_login"`
	SmtpPassword               basetypes.StringValue `tfsdk:"smtp_password"`
	SpamAction                 basetypes.StringValue `tfsdk:"spam_action"`
	State                      basetypes.StringValue `tfsdk:"state"`
	TrackingHost               basetypes.StringValue `tfsdk:"tracking_host"`
	DomainType                 basetypes.StringValue `tfsdk:"type"`
	UseAutomaticSenderSecurity basetypes.BoolValue   `tfsdk:"use_automatic_sender_security"`
	WebPrefix                  basetypes.StringValue `tfsdk:"web_prefix"`
	WebScheme                  basetypes.StringValue `tfsdk:"web_scheme"`
	Wildcard                   basetypes.BoolValue   `tfsdk:"wildcard"`
	state                      attr.ValueState
}

func (v DomainValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.ObjectType{
		AttrTypes: DisabledValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["require_tls"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["skip_verification"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["smtp_login"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["smtp_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spam_action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tracking_host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_automatic_sender_security"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["web_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["web_scheme"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wildcard"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IsDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_disabled"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RequireTls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["require_tls"] = val

		val, err = v.SkipVerification.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_verification"] = val

		val, err = v.SmtpLogin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["smtp_login"] = val

		val, err = v.SmtpPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["smtp_password"] = val

		val, err = v.SpamAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spam_action"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.TrackingHost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tracking_host"] = val

		val, err = v.DomainType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseAutomaticSenderSecurity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_automatic_sender_security"] = val

		val, err = v.WebPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["web_prefix"] = val

		val, err = v.WebScheme.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["web_scheme"] = val

		val, err = v.Wildcard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wildcard"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DomainValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DomainValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DomainValue) String() string {
	return "DomainValue"
}

func (v DomainValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var disabled basetypes.ObjectValue

	if v.Disabled.IsNull() {
		disabled = types.ObjectNull(
			DisabledValue{}.AttributeTypes(ctx),
		)
	}

	if v.Disabled.IsUnknown() {
		disabled = types.ObjectUnknown(
			DisabledValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Disabled.IsNull() && !v.Disabled.IsUnknown() {
		disabled = types.ObjectValueMust(
			DisabledValue{}.AttributeTypes(ctx),
			v.Disabled.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"disabled": basetypes.ObjectType{
			AttrTypes: DisabledValue{}.AttributeTypes(ctx),
		},
		"id":                            basetypes.StringType{},
		"is_disabled":                   basetypes.BoolType{},
		"name":                          basetypes.StringType{},
		"require_tls":                   basetypes.BoolType{},
		"skip_verification":             basetypes.BoolType{},
		"smtp_login":                    basetypes.StringType{},
		"smtp_password":                 basetypes.StringType{},
		"spam_action":                   basetypes.StringType{},
		"state":                         basetypes.StringType{},
		"tracking_host":                 basetypes.StringType{},
		"type":                          basetypes.StringType{},
		"use_automatic_sender_security": basetypes.BoolType{},
		"web_prefix":                    basetypes.StringType{},
		"web_scheme":                    basetypes.StringType{},
		"wildcard":                      basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":                    v.CreatedAt,
			"disabled":                      disabled,
			"id":                            v.Id,
			"is_disabled":                   v.IsDisabled,
			"name":                          v.Name,
			"require_tls":                   v.RequireTls,
			"skip_verification":             v.SkipVerification,
			"smtp_login":                    v.SmtpLogin,
			"smtp_password":                 v.SmtpPassword,
			"spam_action":                   v.SpamAction,
			"state":                         v.State,
			"tracking_host":                 v.TrackingHost,
			"type":                          v.DomainType,
			"use_automatic_sender_security": v.UseAutomaticSenderSecurity,
			"web_prefix":                    v.WebPrefix,
			"web_scheme":                    v.WebScheme,
			"wildcard":                      v.Wildcard,
		})

	return objVal, diags
}

func (v DomainValue) Equal(o attr.Value) bool {
	other, ok := o.(DomainValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IsDisabled.Equal(other.IsDisabled) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RequireTls.Equal(other.RequireTls) {
		return false
	}

	if !v.SkipVerification.Equal(other.SkipVerification) {
		return false
	}

	if !v.SmtpLogin.Equal(other.SmtpLogin) {
		return false
	}

	if !v.SmtpPassword.Equal(other.SmtpPassword) {
		return false
	}

	if !v.SpamAction.Equal(other.SpamAction) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.TrackingHost.Equal(other.TrackingHost) {
		return false
	}

	if !v.DomainType.Equal(other.DomainType) {
		return false
	}

	if !v.UseAutomaticSenderSecurity.Equal(other.UseAutomaticSenderSecurity) {
		return false
	}

	if !v.WebPrefix.Equal(other.WebPrefix) {
		return false
	}

	if !v.WebScheme.Equal(other.WebScheme) {
		return false
	}

	if !v.Wildcard.Equal(other.Wildcard) {
		return false
	}

	return true
}

func (v DomainValue) Type(ctx context.Context) attr.Type {
	return DomainType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DomainValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"disabled": basetypes.ObjectType{
			AttrTypes: DisabledValue{}.AttributeTypes(ctx),
		},
		"id":                            basetypes.StringType{},
		"is_disabled":                   basetypes.BoolType{},
		"name":                          basetypes.StringType{},
		"require_tls":                   basetypes.BoolType{},
		"skip_verification":             basetypes.BoolType{},
		"smtp_login":                    basetypes.StringType{},
		"smtp_password":                 basetypes.StringType{},
		"spam_action":                   basetypes.StringType{},
		"state":                         basetypes.StringType{},
		"tracking_host":                 basetypes.StringType{},
		"type":                          basetypes.StringType{},
		"use_automatic_sender_security": basetypes.BoolType{},
		"web_prefix":                    basetypes.StringType{},
		"web_scheme":                    basetypes.StringType{},
		"wildcard":                      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = DisabledType{}

type DisabledType struct {
	basetypes.ObjectType
}

func (t DisabledType) Equal(o attr.Type) bool {
	other, ok := o.(DisabledType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DisabledType) String() string {
	return "DisabledType"
}

func (t DisabledType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return nil, diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	permanentlyAttribute, ok := attributes["permanently"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permanently is missing from object`)

		return nil, diags
	}

	permanentlyVal, ok := permanentlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permanently expected to be basetypes.BoolValue, was: %T`, permanentlyAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return nil, diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	untilAttribute, ok := attributes["until"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`until is missing from object`)

		return nil, diags
	}

	untilVal, ok := untilAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`until expected to be basetypes.StringValue, was: %T`, untilAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DisabledValue{
		Code:        codeVal,
		Note:        noteVal,
		Permanently: permanentlyVal,
		Reason:      reasonVal,
		Until:       untilVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDisabledValueNull() DisabledValue {
	return DisabledValue{
		state: attr.ValueStateNull,
	}
}

func NewDisabledValueUnknown() DisabledValue {
	return DisabledValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDisabledValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DisabledValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DisabledValue Attribute Value",
				"While creating a DisabledValue value, a missing attribute value was detected. "+
					"A DisabledValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DisabledValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DisabledValue Attribute Type",
				"While creating a DisabledValue value, an invalid attribute value was detected. "+
					"A DisabledValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DisabledValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DisabledValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DisabledValue Attribute Value",
				"While creating a DisabledValue value, an extra attribute value was detected. "+
					"A DisabledValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DisabledValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDisabledValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewDisabledValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return NewDisabledValueUnknown(), diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	permanentlyAttribute, ok := attributes["permanently"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permanently is missing from object`)

		return NewDisabledValueUnknown(), diags
	}

	permanentlyVal, ok := permanentlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permanently expected to be basetypes.BoolValue, was: %T`, permanentlyAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return NewDisabledValueUnknown(), diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	untilAttribute, ok := attributes["until"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`until is missing from object`)

		return NewDisabledValueUnknown(), diags
	}

	untilVal, ok := untilAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`until expected to be basetypes.StringValue, was: %T`, untilAttribute))
	}

	if diags.HasError() {
		return NewDisabledValueUnknown(), diags
	}

	return DisabledValue{
		Code:        codeVal,
		Note:        noteVal,
		Permanently: permanentlyVal,
		Reason:      reasonVal,
		Until:       untilVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDisabledValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DisabledValue {
	object, diags := NewDisabledValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDisabledValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DisabledType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDisabledValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDisabledValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDisabledValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDisabledValueMust(DisabledValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DisabledType) ValueType(ctx context.Context) attr.Value {
	return DisabledValue{}
}

var _ basetypes.ObjectValuable = DisabledValue{}

type DisabledValue struct {
	Code        basetypes.StringValue `tfsdk:"code"`
	Note        basetypes.StringValue `tfsdk:"note"`
	Permanently basetypes.BoolValue   `tfsdk:"permanently"`
	Reason      basetypes.StringValue `tfsdk:"reason"`
	Until       basetypes.StringValue `tfsdk:"until"`
	state       attr.ValueState
}

func (v DisabledValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["note"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permanently"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["until"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Note.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["note"] = val

		val, err = v.Permanently.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permanently"] = val

		val, err = v.Reason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reason"] = val

		val, err = v.Until.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["until"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DisabledValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DisabledValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DisabledValue) String() string {
	return "DisabledValue"
}

func (v DisabledValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"code":        basetypes.StringType{},
		"note":        basetypes.StringType{},
		"permanently": basetypes.BoolType{},
		"reason":      basetypes.StringType{},
		"until":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"code":        v.Code,
			"note":        v.Note,
			"permanently": v.Permanently,
			"reason":      v.Reason,
			"until":       v.Until,
		})

	return objVal, diags
}

func (v DisabledValue) Equal(o attr.Value) bool {
	other, ok := o.(DisabledValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Note.Equal(other.Note) {
		return false
	}

	if !v.Permanently.Equal(other.Permanently) {
		return false
	}

	if !v.Reason.Equal(other.Reason) {
		return false
	}

	if !v.Until.Equal(other.Until) {
		return false
	}

	return true
}

func (v DisabledValue) Type(ctx context.Context) attr.Type {
	return DisabledType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DisabledValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":        basetypes.StringType{},
		"note":        basetypes.StringType{},
		"permanently": basetypes.BoolType{},
		"reason":      basetypes.StringType{},
		"until":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ReceivingDnsRecordsType{}

type ReceivingDnsRecordsType struct {
	basetypes.ObjectType
}

func (t ReceivingDnsRecordsType) Equal(o attr.Type) bool {
	other, ok := o.(ReceivingDnsRecordsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReceivingDnsRecordsType) String() string {
	return "ReceivingDnsRecordsType"
}

func (t ReceivingDnsRecordsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cachedAttribute, ok := attributes["cached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cached is missing from object`)

		return nil, diags
	}

	cachedVal, ok := cachedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cached expected to be basetypes.ListValue, was: %T`, cachedAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	recordTypeAttribute, ok := attributes["record_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_type is missing from object`)

		return nil, diags
	}

	recordTypeVal, ok := recordTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_type expected to be basetypes.StringValue, was: %T`, recordTypeAttribute))
	}

	validAttribute, ok := attributes["valid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid is missing from object`)

		return nil, diags
	}

	validVal, ok := validAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid expected to be basetypes.StringValue, was: %T`, validAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReceivingDnsRecordsValue{
		Cached:     cachedVal,
		IsActive:   isActiveVal,
		Name:       nameVal,
		Priority:   priorityVal,
		RecordType: recordTypeVal,
		Valid:      validVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewReceivingDnsRecordsValueNull() ReceivingDnsRecordsValue {
	return ReceivingDnsRecordsValue{
		state: attr.ValueStateNull,
	}
}

func NewReceivingDnsRecordsValueUnknown() ReceivingDnsRecordsValue {
	return ReceivingDnsRecordsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReceivingDnsRecordsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReceivingDnsRecordsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReceivingDnsRecordsValue Attribute Value",
				"While creating a ReceivingDnsRecordsValue value, a missing attribute value was detected. "+
					"A ReceivingDnsRecordsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReceivingDnsRecordsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReceivingDnsRecordsValue Attribute Type",
				"While creating a ReceivingDnsRecordsValue value, an invalid attribute value was detected. "+
					"A ReceivingDnsRecordsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReceivingDnsRecordsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReceivingDnsRecordsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReceivingDnsRecordsValue Attribute Value",
				"While creating a ReceivingDnsRecordsValue value, an extra attribute value was detected. "+
					"A ReceivingDnsRecordsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReceivingDnsRecordsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	cachedAttribute, ok := attributes["cached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cached is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	cachedVal, ok := cachedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cached expected to be basetypes.ListValue, was: %T`, cachedAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	recordTypeAttribute, ok := attributes["record_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_type is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	recordTypeVal, ok := recordTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_type expected to be basetypes.StringValue, was: %T`, recordTypeAttribute))
	}

	validAttribute, ok := attributes["valid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	validVal, ok := validAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid expected to be basetypes.StringValue, was: %T`, validAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewReceivingDnsRecordsValueUnknown(), diags
	}

	return ReceivingDnsRecordsValue{
		Cached:     cachedVal,
		IsActive:   isActiveVal,
		Name:       nameVal,
		Priority:   priorityVal,
		RecordType: recordTypeVal,
		Valid:      validVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewReceivingDnsRecordsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReceivingDnsRecordsValue {
	object, diags := NewReceivingDnsRecordsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReceivingDnsRecordsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReceivingDnsRecordsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReceivingDnsRecordsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReceivingDnsRecordsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReceivingDnsRecordsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReceivingDnsRecordsValueMust(ReceivingDnsRecordsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReceivingDnsRecordsType) ValueType(ctx context.Context) attr.Value {
	return ReceivingDnsRecordsValue{}
}

var _ basetypes.ObjectValuable = ReceivingDnsRecordsValue{}

type ReceivingDnsRecordsValue struct {
	Cached     basetypes.ListValue   `tfsdk:"cached"`
	IsActive   basetypes.BoolValue   `tfsdk:"is_active"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Priority   basetypes.StringValue `tfsdk:"priority"`
	RecordType basetypes.StringValue `tfsdk:"record_type"`
	Valid      basetypes.StringValue `tfsdk:"valid"`
	Value      basetypes.StringValue `tfsdk:"value"`
	state      attr.ValueState
}

func (v ReceivingDnsRecordsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["cached"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["priority"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Cached.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cached"] = val

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		val, err = v.RecordType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_type"] = val

		val, err = v.Valid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReceivingDnsRecordsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReceivingDnsRecordsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReceivingDnsRecordsValue) String() string {
	return "ReceivingDnsRecordsValue"
}

func (v ReceivingDnsRecordsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cachedVal basetypes.ListValue
	switch {
	case v.Cached.IsUnknown():
		cachedVal = types.ListUnknown(types.StringType)
	case v.Cached.IsNull():
		cachedVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		cachedVal, d = types.ListValue(types.StringType, v.Cached.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cached": basetypes.ListType{
				ElemType: types.StringType,
			},
			"is_active":   basetypes.BoolType{},
			"name":        basetypes.StringType{},
			"priority":    basetypes.StringType{},
			"record_type": basetypes.StringType{},
			"valid":       basetypes.StringType{},
			"value":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cached": basetypes.ListType{
			ElemType: types.StringType,
		},
		"is_active":   basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"priority":    basetypes.StringType{},
		"record_type": basetypes.StringType{},
		"valid":       basetypes.StringType{},
		"value":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cached":      cachedVal,
			"is_active":   v.IsActive,
			"name":        v.Name,
			"priority":    v.Priority,
			"record_type": v.RecordType,
			"valid":       v.Valid,
			"value":       v.Value,
		})

	return objVal, diags
}

func (v ReceivingDnsRecordsValue) Equal(o attr.Value) bool {
	other, ok := o.(ReceivingDnsRecordsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cached.Equal(other.Cached) {
		return false
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	if !v.RecordType.Equal(other.RecordType) {
		return false
	}

	if !v.Valid.Equal(other.Valid) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ReceivingDnsRecordsValue) Type(ctx context.Context) attr.Type {
	return ReceivingDnsRecordsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReceivingDnsRecordsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cached": basetypes.ListType{
			ElemType: types.StringType,
		},
		"is_active":   basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"priority":    basetypes.StringType{},
		"record_type": basetypes.StringType{},
		"valid":       basetypes.StringType{},
		"value":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SendingDnsRecordsType{}

type SendingDnsRecordsType struct {
	basetypes.ObjectType
}

func (t SendingDnsRecordsType) Equal(o attr.Type) bool {
	other, ok := o.(SendingDnsRecordsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SendingDnsRecordsType) String() string {
	return "SendingDnsRecordsType"
}

func (t SendingDnsRecordsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cachedAttribute, ok := attributes["cached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cached is missing from object`)

		return nil, diags
	}

	cachedVal, ok := cachedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cached expected to be basetypes.ListValue, was: %T`, cachedAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	recordTypeAttribute, ok := attributes["record_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_type is missing from object`)

		return nil, diags
	}

	recordTypeVal, ok := recordTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_type expected to be basetypes.StringValue, was: %T`, recordTypeAttribute))
	}

	validAttribute, ok := attributes["valid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid is missing from object`)

		return nil, diags
	}

	validVal, ok := validAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid expected to be basetypes.StringValue, was: %T`, validAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SendingDnsRecordsValue{
		Cached:     cachedVal,
		IsActive:   isActiveVal,
		Name:       nameVal,
		Priority:   priorityVal,
		RecordType: recordTypeVal,
		Valid:      validVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSendingDnsRecordsValueNull() SendingDnsRecordsValue {
	return SendingDnsRecordsValue{
		state: attr.ValueStateNull,
	}
}

func NewSendingDnsRecordsValueUnknown() SendingDnsRecordsValue {
	return SendingDnsRecordsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSendingDnsRecordsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SendingDnsRecordsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SendingDnsRecordsValue Attribute Value",
				"While creating a SendingDnsRecordsValue value, a missing attribute value was detected. "+
					"A SendingDnsRecordsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendingDnsRecordsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SendingDnsRecordsValue Attribute Type",
				"While creating a SendingDnsRecordsValue value, an invalid attribute value was detected. "+
					"A SendingDnsRecordsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendingDnsRecordsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SendingDnsRecordsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SendingDnsRecordsValue Attribute Value",
				"While creating a SendingDnsRecordsValue value, an extra attribute value was detected. "+
					"A SendingDnsRecordsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SendingDnsRecordsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSendingDnsRecordsValueUnknown(), diags
	}

	cachedAttribute, ok := attributes["cached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cached is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	cachedVal, ok := cachedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cached expected to be basetypes.ListValue, was: %T`, cachedAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	recordTypeAttribute, ok := attributes["record_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_type is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	recordTypeVal, ok := recordTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_type expected to be basetypes.StringValue, was: %T`, recordTypeAttribute))
	}

	validAttribute, ok := attributes["valid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	validVal, ok := validAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid expected to be basetypes.StringValue, was: %T`, validAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewSendingDnsRecordsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewSendingDnsRecordsValueUnknown(), diags
	}

	return SendingDnsRecordsValue{
		Cached:     cachedVal,
		IsActive:   isActiveVal,
		Name:       nameVal,
		Priority:   priorityVal,
		RecordType: recordTypeVal,
		Valid:      validVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSendingDnsRecordsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SendingDnsRecordsValue {
	object, diags := NewSendingDnsRecordsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSendingDnsRecordsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SendingDnsRecordsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSendingDnsRecordsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSendingDnsRecordsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSendingDnsRecordsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSendingDnsRecordsValueMust(SendingDnsRecordsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SendingDnsRecordsType) ValueType(ctx context.Context) attr.Value {
	return SendingDnsRecordsValue{}
}

var _ basetypes.ObjectValuable = SendingDnsRecordsValue{}

type SendingDnsRecordsValue struct {
	Cached     basetypes.ListValue   `tfsdk:"cached"`
	IsActive   basetypes.BoolValue   `tfsdk:"is_active"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Priority   basetypes.StringValue `tfsdk:"priority"`
	RecordType basetypes.StringValue `tfsdk:"record_type"`
	Valid      basetypes.StringValue `tfsdk:"valid"`
	Value      basetypes.StringValue `tfsdk:"value"`
	state      attr.ValueState
}

func (v SendingDnsRecordsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["cached"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["priority"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Cached.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cached"] = val

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		val, err = v.RecordType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_type"] = val

		val, err = v.Valid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SendingDnsRecordsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SendingDnsRecordsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SendingDnsRecordsValue) String() string {
	return "SendingDnsRecordsValue"
}

func (v SendingDnsRecordsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cachedVal basetypes.ListValue
	switch {
	case v.Cached.IsUnknown():
		cachedVal = types.ListUnknown(types.StringType)
	case v.Cached.IsNull():
		cachedVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		cachedVal, d = types.ListValue(types.StringType, v.Cached.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cached": basetypes.ListType{
				ElemType: types.StringType,
			},
			"is_active":   basetypes.BoolType{},
			"name":        basetypes.StringType{},
			"priority":    basetypes.StringType{},
			"record_type": basetypes.StringType{},
			"valid":       basetypes.StringType{},
			"value":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cached": basetypes.ListType{
			ElemType: types.StringType,
		},
		"is_active":   basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"priority":    basetypes.StringType{},
		"record_type": basetypes.StringType{},
		"valid":       basetypes.StringType{},
		"value":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cached":      cachedVal,
			"is_active":   v.IsActive,
			"name":        v.Name,
			"priority":    v.Priority,
			"record_type": v.RecordType,
			"valid":       v.Valid,
			"value":       v.Value,
		})

	return objVal, diags
}

func (v SendingDnsRecordsValue) Equal(o attr.Value) bool {
	other, ok := o.(SendingDnsRecordsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cached.Equal(other.Cached) {
		return false
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	if !v.RecordType.Equal(other.RecordType) {
		return false
	}

	if !v.Valid.Equal(other.Valid) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v SendingDnsRecordsValue) Type(ctx context.Context) attr.Type {
	return SendingDnsRecordsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SendingDnsRecordsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cached": basetypes.ListType{
			ElemType: types.StringType,
		},
		"is_active":   basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"priority":    basetypes.StringType{},
		"record_type": basetypes.StringType{},
		"valid":       basetypes.StringType{},
		"value":       basetypes.StringType{},
	}
}
